{"ast":null,"code":"export const START = 10,\n  END = 20,\n  CHEESE = 5,\n  WALLS = -1,\n  HAMBURGUER = 0,\n  HAMBURGUER_VOID = 1;\nexport function Corrds1D_2D(index, lines, columns) {\n  return {\n    x: index % columns,\n    y: Math.floor(index / lines)\n  };\n}\n_c = Corrds1D_2D;\nexport function Corrds2D_1D(line, column, elementsByLine) {\n  return line * elementsByLine + column;\n}\n_c2 = Corrds2D_1D;\nexport function CheesesAround(board, index, boardSize) {\n  var coord = Corrds1D_2D(index, boardSize, boardSize);\n  const possibilities = [{\n    x: coord.x + 1,\n    y: coord.y\n  }, {\n    x: coord.x - 1,\n    y: coord.y\n  }, {\n    x: coord.x,\n    y: coord.y + 1\n  }, {\n    x: coord.x,\n    y: coord.y - 1\n  }].filter(c => c.x >= 0 && c.x < boardSize && c.y >= 0 && c.y < boardSize && board[Corrds2D_1D(c.y, c.x, boardSize)] === CHEESE);\n  return possibilities.map(x => Corrds2D_1D(x.y, x.x, boardSize));\n}\n_c3 = CheesesAround;\nconst posToString = pos => `(${pos.x},${pos.y})`;\nconst isValid = (board, pos, n, moveChunks, visited) => {\n  return pos.x < n && pos.x >= 0 && pos.y < n && pos.y >= 0 && moveChunks.includes(board[Corrds2D_1D(pos.y, pos.x, n)]) && !visited.includes(posToString(pos));\n};\nexport function explore(board, startPost, moveChunks, n, targetPos) {\n  if (board.length === 0) return [];\n  let stack = [[startPost]];\n  while (stack.length > 0) {\n    const path = stack.shift();\n    const pos = path.at(-1);\n    if (pos.x === targetPos.x && pos.y === targetPos.y) return path;\n    const moves = [{\n      x: pos.x,\n      y: pos.y + 1\n    }, {\n      x: pos.x,\n      y: pos.y - 1\n    }, {\n      x: pos.x + 1,\n      y: pos.y\n    }, {\n      x: pos.x - 1,\n      y: pos.y\n    }].filter(x => isValid(board, x, n, moveChunks, path.map(x => posToString(x))));\n    for (const next of moves) {\n      stack.push([...path, next]);\n    }\n  }\n  return [];\n}\nexport function RandomMoves(board, startPos, moveChunks, n, targetpos) {\n  if (board.length === 0) return [];\n  let pos = startPos;\n  let visited = [posToString(pos)];\n  let interactions = 100; // Controlle the max interactions in while loop\n  const path = [pos];\n  while (path.length > 0) {\n    if (interactions <= 0) return explore(board, startPos, moveChunks, n, targetpos);\n    const moves = [{\n      x: pos.x + 1,\n      y: pos.y\n    }, {\n      x: pos.x - 1,\n      y: pos.y\n    }, {\n      x: pos.x,\n      y: pos.y + 1\n    }, {\n      x: pos.x,\n      y: pos.y - 1\n    }].filter(x => isValid(board, x, n, moveChunks, visited));\n    if (moves.length === 0) {\n      pos = path.shift();\n      continue;\n    }\n    const randomMove = moves[Math.floor(Math.random() * moves.length)];\n    pos = randomMove;\n    if (pos.x === targetpos.x && pos.y === targetpos.y) {\n      path.push(pos);\n      return path.length > board.length / 3 ? explore(board, startPos, moveChunks, n, targetpos) : path;\n    }\n    path.push(pos);\n    visited.push(posToString(pos));\n    interactions--;\n  }\n  return path.length > board.length / 3 ? explore(board, startPos, moveChunks, n, targetpos) : path;\n}\n_c4 = RandomMoves;\nfunction CheckCheese(board, n) {\n  if (board.indexOf(CHEESE) === -1) return false;\n  let cheese = Corrds1D_2D(board.indexOf(CHEESE), n, n);\n  let start = Corrds1D_2D(board.indexOf(START), n, n);\n  return explore(board, start, [START, HAMBURGUER, CHEESE], n, cheese).length > 0;\n}\n\n// n -> board size 9x9\n// Return the number of Meet, player can collect\n_c5 = CheckCheese;\nexport function MeetCanCollect(board, n) {\n  const visited = [];\n  var pos = Corrds1D_2D(board.indexOf(START), n, n);\n  const backtrack = pos => {\n    const moves = [{\n      x: pos.x + 1,\n      y: pos.y\n    }, {\n      x: pos.x - 1,\n      y: pos.y\n    }, {\n      x: pos.x,\n      y: pos.y + 1\n    }, {\n      x: pos.x,\n      y: pos.y - 1\n    }].filter(x => isValid(board, x, n, [HAMBURGUER], visited));\n    if (!visited.includes(posToString(pos))) visited.push(posToString(pos));\n    for (var coord of moves) {\n      backtrack(coord);\n    }\n  };\n  backtrack(pos);\n  return visited.filter(x => x !== posToString(pos)).length;\n}\n_c6 = MeetCanCollect;\nexport function CheckWin(board, n) {\n  let pos = Corrds1D_2D(board.indexOf(START), n, n);\n  return explore(board, pos, [HAMBURGUER_VOID, START, END], n, Corrds1D_2D(board.indexOf(END), n, n)).length > 0;\n}\n_c7 = CheckWin;\nexport function CanResolve(board, n) {\n  let pos = Corrds1D_2D(board.indexOf(START), n, n);\n  const colectCheese = CheckCheese(board, n);\n  const finish = explore(board, pos, [START, END, HAMBURGUER], n, Corrds1D_2D(board.indexOf(END), n, n));\n  if (board.indexOf(CHEESE) === -1) return finish.length > 0;\n  return colectCheese && finish.length > 0;\n}\n_c8 = CanResolve;\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8;\n$RefreshReg$(_c, \"Corrds1D_2D\");\n$RefreshReg$(_c2, \"Corrds2D_1D\");\n$RefreshReg$(_c3, \"CheesesAround\");\n$RefreshReg$(_c4, \"RandomMoves\");\n$RefreshReg$(_c5, \"CheckCheese\");\n$RefreshReg$(_c6, \"MeetCanCollect\");\n$RefreshReg$(_c7, \"CheckWin\");\n$RefreshReg$(_c8, \"CanResolve\");","map":{"version":3,"names":["START","END","CHEESE","WALLS","HAMBURGUER","HAMBURGUER_VOID","Corrds1D_2D","index","lines","columns","x","y","Math","floor","_c","Corrds2D_1D","line","column","elementsByLine","_c2","CheesesAround","board","boardSize","coord","possibilities","filter","c","map","_c3","posToString","pos","isValid","n","moveChunks","visited","includes","explore","startPost","targetPos","length","stack","path","shift","at","moves","next","push","RandomMoves","startPos","targetpos","interactions","randomMove","random","_c4","CheckCheese","indexOf","cheese","start","_c5","MeetCanCollect","backtrack","_c6","CheckWin","_c7","CanResolve","colectCheese","finish","_c8","$RefreshReg$"],"sources":["L:/Bacon/src/Match/CheckWin.js"],"sourcesContent":["export const START = 10, END = 20, CHEESE = 5, WALLS = -1, HAMBURGUER = 0, HAMBURGUER_VOID = 1\r\n\r\nexport function Corrds1D_2D(index, lines, columns) {\r\n  return { x: index % columns, y: Math.floor(index / lines) };\r\n}\r\n\r\nexport function Corrds2D_1D(line, column, elementsByLine) {\r\n  return line * elementsByLine + column;\r\n}\r\n\r\nexport function CheesesAround(board,index,boardSize){\r\n  var coord = Corrds1D_2D(index,boardSize,boardSize)\r\n  const possibilities = [\r\n    {x: coord.x + 1, y: coord.y},\r\n    {x: coord.x - 1, y: coord.y},\r\n    {x: coord.x, y: coord.y + 1},\r\n    {x: coord.x, y: coord.y - 1},\r\n  ].filter((c) => c.x >= 0 && c.x < boardSize && c.y >= 0 && c.y < boardSize && board[Corrds2D_1D(c.y,c.x,boardSize)] === CHEESE)\r\n  return possibilities.map((x) => Corrds2D_1D(x.y,x.x,boardSize))\r\n}\r\n\r\nconst posToString = (pos) => `(${pos.x},${pos.y})`;\r\n\r\nconst isValid = (board,pos,n,moveChunks,visited) => {\r\n  return (\r\n    pos.x < n && pos.x >= 0 && pos.y < n && pos.y >= 0 &&\r\n    moveChunks.includes(board[Corrds2D_1D(pos.y, pos.x, n)]) &&\r\n    !visited.includes(posToString(pos))\r\n  );\r\n};\r\n\r\nexport function explore(board, startPost, moveChunks, n, targetPos) {\r\n  if (board.length === 0) return [];\r\n  let stack = [[startPost]];\r\n\r\n  while (stack.length > 0) {\r\n    const path = stack.shift();\r\n    const pos = path.at(-1);\r\n\r\n    if (pos.x === targetPos.x && pos.y === targetPos.y) return path\r\n\r\n    const moves = [\r\n      { x: pos.x, y: pos.y + 1 },\r\n      { x: pos.x, y: pos.y - 1 },\r\n      { x: pos.x + 1, y: pos.y },\r\n      { x: pos.x - 1, y: pos.y },\r\n    ].filter((x) => isValid(board,x,n,moveChunks,path.map((x) => posToString(x))));\r\n    for (const next of moves) {\r\n      stack.push([...path, next]);\r\n    }\r\n  }\r\n  return [];\r\n}\r\n\r\nexport function RandomMoves(board, startPos, moveChunks, n, targetpos){\r\n  if (board.length === 0) return []\r\n  let pos = startPos\r\n  let visited = [posToString(pos)]\r\n  let interactions = 100 // Controlle the max interactions in while loop\r\n  const path = [pos]\r\n\r\n\r\n  while(path.length > 0){\r\n    if (interactions <= 0) return explore(board,startPos,moveChunks,n,targetpos)\r\n    const moves = [\r\n      {x: pos.x + 1, y: pos.y},\r\n      {x: pos.x - 1, y: pos.y},\r\n      {x: pos.x, y: pos.y + 1},\r\n      {x: pos.x, y: pos.y - 1},\r\n      ].filter((x) => isValid(board,x,n,moveChunks,visited))\r\n    if (moves.length === 0){\r\n      pos = path.shift()\r\n      continue\r\n    }\r\n    const randomMove = moves[Math.floor(Math.random() * moves.length)]\r\n    pos = randomMove\r\n    if (pos.x === targetpos.x && pos.y === targetpos.y) {\r\n      path.push(pos)\r\n      return (path.length > board.length/3) ? explore(board,startPos,moveChunks,n,targetpos) : path\r\n    }\r\n    path.push(pos)\r\n    visited.push(posToString(pos))\r\n    interactions--\r\n  }\r\n  return (path.length > board.length/3) ? explore(board,startPos,moveChunks,n,targetpos) : path\r\n}\r\n\r\nfunction CheckCheese(board, n){\r\n  if (board.indexOf(CHEESE) === -1) return false\r\n  let cheese = Corrds1D_2D(board.indexOf(CHEESE),n,n)\r\n  let start = Corrds1D_2D(board.indexOf(START),n,n)\r\n  return explore(board, start, [START,HAMBURGUER,CHEESE], n, cheese).length > 0\r\n}\r\n\r\n// n -> board size 9x9\r\n// Return the number of Meet, player can collect\r\nexport function MeetCanCollect(board, n){\r\n  const visited = []\r\n  var pos = Corrds1D_2D(board.indexOf(START),n,n)\r\n\r\n  const backtrack = (pos) => {\r\n    const moves = [\r\n      {x: pos.x + 1, y: pos.y},\r\n      {x: pos.x - 1, y: pos.y},\r\n      {x: pos.x, y: pos.y + 1},\r\n      {x: pos.x, y: pos.y - 1},\r\n    ].filter((x) => isValid(board,x,n,[HAMBURGUER],visited))\r\n    if (!visited.includes(posToString(pos))) visited.push(posToString(pos))\r\n    for (var coord of moves){ backtrack(coord) }\r\n  }\r\n  backtrack(pos)\r\n  return visited.filter((x) => x !== posToString(pos)).length\r\n}\r\n\r\nexport function CheckWin(board, n) {\r\n  let pos = Corrds1D_2D(board.indexOf(START), n, n);\r\n  return explore(board, pos, [HAMBURGUER_VOID, START, END], n, Corrds1D_2D(board.indexOf(END), n, n)).length > 0\r\n}\r\n\r\nexport function CanResolve(board, n) {\r\n  let pos = Corrds1D_2D(board.indexOf(START), n, n);\r\n  const colectCheese = CheckCheese(board,n)\r\n  const finish = explore(board, pos, [START, END, HAMBURGUER], n, Corrds1D_2D(board.indexOf(END), n, n))\r\n  if (board.indexOf(CHEESE) === -1) return finish.length > 0\r\n  return colectCheese && finish.length > 0\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}